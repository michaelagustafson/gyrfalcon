---
title: "04_addhabitat"
author: "Michaela Gustafson"
date: "1/1/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Adding Habitat Data from ABoVE Dataset

In this code I will be importing GPS points for 2019 and 2021 prey surveys.

I will be adding land cover raster data from: https://daac.ornl.gov/ABOVE/guides/Annual_Landcover_ABoVE.html

1. I will group land cover types into more broad categories.
2. Create a separate layer for each land cover type.
3. Run a focal function for a 390m buffer to be able to extract the proportion of that habitat type within a 390(400m) buffer around each survey point


## LIBRARY
These are the packages used in this code:
```{r library}
library(terra)
library(sf)
library(sp)
library(rgdal)
library(ggplot2)
library(tidyverse)
library(raster)
library(tidyr)
library(dplyr)
library(stringr)
library(rgeos)
```

## IMPORT DEM
Import elevation raster and get land cover and elevation to have same origin, CRS, and extent
```{r dem}
ak_dem <- raster::raster("D:/GYRF/Gyrfalcon/gyrfalcon/data/DEM_Michaela/DEM_Michaela/dsm_mosaic_AK.tif")
```



## UPLOAD LAND COVER RASTERS
I will be selecting out the files that have the land cover for 2014. The four tiles called in below cover the study area.

```{r landcover}

test.tif.14 <- raster::raster("D:/GYRF/Gyrfalcon/gyrfalcon/data/ABoVE_2014lyrs/ABoVE_LandCover_Bh04v01_2014.tif")
test.tif2.14 <- raster::raster("D:/GYRF/Gyrfalcon/gyrfalcon/data/ABoVE_2014lyrs/ABoVE_LandCover_Bh04v02_2014.tif")
test.tif3.14 <- raster::raster("D:/GYRF/Gyrfalcon/gyrfalcon/data/ABoVE_2014lyrs/ABoVE_LandCover_Bh03v01_2014.tif")
test.tif4.14 <- raster::raster("D:/GYRF/Gyrfalcon/gyrfalcon/data/ABoVE_2014lyrs/ABoVE_LandCover_Bh03v02_2014.tif")

r <- raster::merge(test.tif.14, test.tif2.14, test.tif3.14, test.tif4.14)
r[r <= 0 ] <- NA

plot(r)

writeRaster(r, "D:/GYRF/Gyrfalcon/gyrfalcon/data/ABoVE_2014lyrs/all.mos.tif", overwrite = TRUE)


```


## IMPORT SURVEY LOCATIONS

2019 survey locations are in lat/lon. 2021 survey locations are in UTMs.
I will be converting 2021 points to lat/lon.


### 2019

The recorded lat/lon ended up being in weird locations so I pulled the lat/lon directly from the gps (finalwp_2019.csv) and will be matching the lat/lon waypoints with those recorded in the orignial data sheet ("Point_Count_Env_2019_MG_cleaned.csv")

In 2019 data, there are points not taken for some survey locations so I will be importing the predetermined lat/lon locations for those from the file imported from the GPS (originalpoints_2019.csv)

At the moment, not sure what I used the backup points for...

```{r pointimport}

points.19 <- read.csv("D:/GYRF/Gyrfalcon/gyrfalcon/data/Point_Count_Env_2019_MG_cleaned.csv")
gpx.19 <- read.csv("D:/GYRF/Gyrfalcon/gyrfalcon/data/finalwp_2019.csv")
ogpoints.19 <- read.csv("D:/GYRF/Gyrfalcon/gyrfalcon/data/originalpoints_2019.csv", skip = 22)
backup.19 <- read.csv("D:/GYRF/Gyrfalcon/gyrfalcon/data/GPS002_2019backup.csv", skip = 22)

# There are extra '1' at the end of the waypoint number names, need to remove them so the key id will match when merging dataframes
backup.19$name = str_remove(backup.19$name, "^0")


# match key id names
gpx.19 <- rename(gpx.19, Waypoint_num = name)
# add leading zero to key id in points.19 to match key id (Waypoint Name)
points.19$Waypoint_num <- str_pad(points.19$Waypoint_num, 3, pad = "0")
# join points and locations from GPS together
points.gpx.join <- left_join(points.19, gpx.19)

# create id key column
points.gpx.join$id <- paste(points.gpx.join$Road_ID, points.gpx.join$UNIT_ID, points.gpx.join$Transect_ID, points.gpx.join$Point_ID, sep = "_")
head(points.gpx.join)


colnames(points.gpx.join)

# only keep columns need
points.2019 <- points.gpx.join[,c(35, 28:29)]
head(points.2019)
# lat lon are empty because I will be pulling that data in from the correct gpx file or original points file. 

# separating out the first 17 surveyed points that don't have matching waypoint
# names in the gps files
missing.points <- points.gpx.join[c(1:17),]

# separate into KOUG and TELL points for naming purposes
miss.points.koug <- missing.points[c(1:11),]
miss.points.tell <- missing.points[c(12:17),]
# Need id names to match those on the points gpx

# Add K or T to column characters respectively so that columns have matching id keys
# and I can bind/join table together 
miss.points.koug$UNIT_ID <- paste("K", miss.points.koug$UNIT_ID, sep = "")
miss.points.tell$UNIT_ID <- paste("T", miss.points.tell$UNIT_ID, sep = "")
miss.points.koug$Transect_ID <- paste("T", miss.points.koug$Transect_ID, sep = "")
miss.points.tell$Transect_ID <- paste("T", miss.points.tell$Transect_ID, sep = "")


# bind all points back together into one dataframe
missing.points <- rbind(miss.points.koug, miss.points.tell)

# create the universal id column in the dataframe of missing points
missing.points$name <- paste(missing.points$UNIT_ID, missing.points$Transect_ID, missing.points$Point_ID, sep = "_")

# join the missing points to dataframe to data taken off GPS to get true lat/lon
# for these points
miss.og.point.join <- left_join(missing.points, ogpoints.19, by = "name")


# only keep columns needed and rename them
colnames(miss.og.point.join)
miss.og.points <- miss.og.point.join[,c(36, 38,39)]
miss.og.points <- rename(miss.og.points, "lat" = "lat.y")
miss.og.points <- rename(miss.og.points, "lon" = "lon.y")
miss.og.points <- rename(miss.og.points, "id" = "name")


### NEED TO CHANGE Column ID NAMES BACK TO MATCH POINTS 2019

koug.names <- as.data.frame(miss.points.koug$id)
koug.names <- rename(koug.names, 'id' = 'miss.points.koug$id')
tell.names <- as.data.frame(miss.points.tell$id)
tell.names <- rename(tell.names, 'id' = 'miss.points.tell$id')
miss.names <- rbind(koug.names, tell.names)


miss.og.points$id <- miss.names$id
str(miss.og.points)

#######################################################################
# remove those incorrect 'missing points' from the dataframe so I can correctly add them in later
points.2019 <- points.2019[complete.cases(points.2019),]

# add corrected points with true lat/lon
points.2019.all <- rbind(miss.og.points, points.2019)

# save CSV of these fixed points and full df for safe keeping
write.csv(points.2019.all, ("D:/GYRF/Gyrfalcon/gyrfalcon/output/points_2019_all_FINAL.csv"))

## assign crs (pulled from Jenny's version cause I like the way she did it better)

#create an xy dataframe of lat and lon points
xy <- points.2019.all[c(3,2)]
# rename columns 'x' and 'y'
colnames(xy)[1] <- "x"; colnames(xy)[2] <- "y"
# turn into numeric object
xy[,1:2] <- sapply(xy[,1:2], as.numeric)
#turn into coordinates string
coordinates(xy) <- ~ x + y
# now turn into spatial points dataframe matching the newly made saptial points data frame coordinates to the associated data from the original dataframe
spdf <- SpatialPointsDataFrame(coords = xy, data = points.2019.all)
# assing CRS that points were collected in on GPS
proj4string(spdf) <- CRS("+init=epsg:4326")
# reprojeting it to DEM crs first to create extent to crop DEM to more manageable size
points19.proj <- spTransform(spdf, crs(ak_dem)) 
plot(ak_dem); points(points19.proj)
writeOGR(points19.proj, dsn="D:/GYRF/Gyrfalcon/gyrfalcon/data", layer="pts19" , driver="ESRI Shapefile")

# now reproject to crs of land cover data and save
points19.proj.lc <- spTransform(spdf, crs(r))
writeOGR(points19.proj.lc, dsn="D:/GYRF/Gyrfalcon/gyrfalcon/data", layer="pts19.proj.lc" , driver="ESRI Shapefile")


```


### 2021

```{r 21points}

##### 2021 #####
points.21 <- read.csv("D:/GYRF/Gyrfalcon/gyrfalcon/data/Point_Count_Env_2021_MG.csv")
head(points.21); dim(points.21)

# subset id and utms
colnames(points.21)
points.21 <- points.21[,c(1:4, 19:20)]
points.21$id <- paste(points.21$ROAD_ID, points.21$UNIT_ID, points.21$TRANSECT_ID, points.21$POINT_ID, sep = "_")

head(points.21)
#subset again to keep only final key id and utms
points.21 <- points.21[,c(7, 5:6)]
head(points.21); dim(points.21)
# export for safe keeping
write.csv(points.21, "D:/GYRF/Gyrfalcon/gyrfalcon/output/utms_21_final.csv")

# now do same thing as with 2019 data to assign CRS
xy2 <- points.21[c(2,3)]
colnames(xy2)[1] <- "x"; colnames(xy2)[2] <- "y"
coordinates(xy2) <- ~ x + y
spdf2 <- SpatialPointsDataFrame(coords = xy2, data = points.21)
proj4string(spdf2) <- CRS("+init=epsg:26903")
points21.proj <- spTransform(spdf2, crs(ak_dem))
plot(ak_dem); points(points21.proj)
writeOGR(points21.proj, dsn="D:/GYRF/Gyrfalcon/gyrfalcon/data", layer="pts21" , driver="ESRI Shapefile")
points21.proj.lc <- spTransform(spdf2, crs(r))
writeOGR(points21.proj.lc, dsn="D:/GYRF/Gyrfalcon/gyrfalcon/data", layer="pts21.proj.lc" , driver="ESRI Shapefile")


```


### Bind 2019 and 2021 points together

```{r ptbind}
points19.proj.lc@data$year <- 2019
points21.proj.lc@data$year <- 2021
new <- bind(points19.proj.lc[c(1,4)], points21.proj.lc[c(1,4)])
writeOGR(new, dsn="D:/GYRF/Gyrfalcon/gyrfalcon/data", layer="pts19&21.proj.lc" , driver="ESRI Shapefile")

```


#### MAKE EXTENT FROM POINTS
```{r makee}
#### make study extent polygon + some extra ######
pts.all <- readOGR("D:/GYRF/Gyrfalcon/gyrfalcon/data", "pts19&21.proj.lc")

#### make study extent polygon + some extra buffer for focal function
e <- extent(points19.proj) 
p <- as(e, 'SpatialPolygons') 
proj4string(p) <- "+proj=aea +lat_0=50 +lon_0=-154 +lat_1=55 +lat_2=65 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs "
e2 <- rgeos::gBuffer(p, width = 5000) # 5km buffer


#### clip dem and land cover by new extent ####
dem.clip <- crop(ak_dem, e2)
dem.clip <- mask(dem.clip, e2)
writeRaster(dem.clip, "D:/GYRF/Gyrfalcon/gyrfalcon/data/dem.clip.tif", overwrite = TRUE)
#projecting raster to land cover CRS
dem.clip <- raster("D:/GYRF/Gyrfalcon/gyrfalcon/data/dem.clip.tif")
dem.clip.lc <- projectRaster(dem.clip, crs = "+proj=aea +lat_0=40 +lon_0=-96 +lat_1=50 +lat_2=70 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs" )
writeRaster(dem.clip.lc, "D:/GYRF/Gyrfalcon/gyrfalcon/data/dem.clip.lc.tif", overwrite = TRUE)

e2.lc <- spTransform(e2, CRS("+proj=aea +lat_0=40 +lon_0=-96 +lat_1=50 +lat_2=70 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs" ))
all.mos.clip <- crop(r, e2.lc)
all.mos.clip <- mask(all.mos.clip, e2.lc)
writeRaster(all.mos.clip, "D:/GYRF/Gyrfalcon/gyrfalcon/data/all.mos.clip.tif", overwrite = TRUE)

```


### Resample DEM from 5x5 to 30x30 to match land cover resolution
```{r}
#### resample dem to 30 x 30 to match land cover #######
all.mos.clip <- raster("D:/GYRF/Gyrfalcon/gyrfalcon/data/all.mos.clip.tif")
df <- as.data.frame(all.mos.clip, xy = TRUE)
res(all.mos.clip) <- 30
all.mos.clip.30 <- all.mos.clip

dem.clip.lc <- raster("D:/GYRF/Gyrfalcon/gyrfalcon/data/dem.clip.lc.tif")
dem.clip.lc.30 <- resample(dem.clip.lc, all.mos.clip.30, method = "bilinear")
writeRaster(dem.clip.lc.30, "D:/GYRF/Gyrfalcon/gyrfalcon/data/dem.clip.lc.30.tif", overwrite = TRUE)

```











## Create separate raster layers for each habitat type

2. Add legend to raster data so we know what number corresponds to what habitat type

```{r lclegend}
aboveLC <- read.csv("D:/GYRF/Gyrfalcon/gyrfalcon/data/ABoVE_LandClass_Labels.csv")
str(aboveLC)
aboveLC$Code <- as.factor(aboveLC$Code)
print(aboveLC)
```

3. Separate out each habitat type

I will group land cover types as so:
Tundra = `Herbaceous`
Tussock = `Tussock Tundra`
Low_Shrub = `Low Shrub`
Bare_Ground = `Barren` + `Sparsely Vegetated`
Tall_Shrub = `Tall Shrub`
Open_Shrub = `Open Shrubs`
Forest = `Deciduous Forest` + `Evergreen Forest` + `Mixed Forest` + 'Woodland'
Wetland = `Fen` + `Shallows/littoral`

```{r separatelayers}

egforest <- (lc.crop == 1)
decforest <- (lc.crop == 2)
mixforest <- (lc.crop == 3)
woodland <- (lc.crop == 4)
lowshrub <- (lc.crop == 5)
tallshrub <- (lc.crop == 6)
openshrub <- (lc.crop == 7)
tundra <- (lc.crop == 8)
tussock <- (lc.crop == 9)
sparseveg <- (lc.crop == 10)
fen <- (lc.crop == 11)
bog <- (lc.crop == 12)
littoral <- (lc.crop == 13)
barren <- (lc.crop == 14)
water <- (lc.crop == 15)


```
4. Combine SpatRasters into a RasterStack
```{r restack}

lc_stack <- raster::stack(egforest, decforest, mixforest, woodland, lowshrub, tallshrub, openshrub, tundra, tussock, sparseveg, fen, bog, littoral, barren, water)

```


4. Run focal function to get how much area is covered by each land cover type in the buffer size of 390m (13x13 30m cells)
```{r focal}
# run a for loop that will use the focal function to calculate the percentage of each habitat type within our 390m square buffer.

# first need to create empty lists that the data from the for loop will be stored in
lc_stack2 <- list()
lc_stack3 <- list()

# heres the loop
for(i in 1:length(lc_stack)){
  lc_stack2[[i]] <- raster::focal(lc_stack[[i]], w=matrix(1, nrow=13, ncol=13), fun=sum, na.rm=TRUE)
  lc_stack3[[i]] <- (lc_stack2[[i]]/169)
}

# restack the layers
lc_stack3 <- raster::stack(lc_stack3)
# now change the names of the columns to match what habitat type they actually are
names(lc_stack3) <- c("egforest", "decforest", "mixforest", "woodland", "lowshrub", "tallshrub", "openshrub", "tundra", "tussock", 'sparseveg', 'fen', 'bog', 'littoral', 'barren', 'water')


# test plot
plot(lc_stack3[[3]])
plot(lc_stack3[[6]])

# save each layer as it own tif
getwd()
writeRaster(lc_stack3, filename=names(lc_stack3), bylayer=TRUE, format="GTiff", overwrite = TRUE)


```
## FOCAL FOR MEAN ELEVATION
```{r focal}
?terra::focal
ak.dem.focal <- raster::focal(ak_dem, w = matrix(1, nc=13, nr=13), fun = mean, na.rm = TRUE)


plot(ak_dem)
plot(ak.dem.focal)

plot(ak.dem.focal.original)
# create raster of focalized dem

writeRaster(ak.dem.focal, filename=file.path(here(), "ak_dem_focal.tif"), overwrite = TRUE)

```
### Read in focalized rasters (so I don't have to rerun this code)

```{r focalreadin}
lc.list <- list.files(here(), pattern = ".tif")
# create a raster stack from the rasters in the list
lc.stack4 <- raster::stack(lc.list[2:16])

#check
plot(lc.stack4[[7]])

e.focal <- raster::raster(lc.list[1])
plot(e.focal)
```








### EXTRACT HABITAT FROM FOCALIZED RAsTERS

## EXTRACT VALUES AT EACH SURVEY POINT
Since we have already calculated the percentage of land cover within a 390m buffer using the focal function, we can now just extract the values at each point without having to do another buffer/function.

1. Extract raster values at each point location
```{r extract}

lc.19 <- raster::extract(lc_stack3, points19.proj)
lc.21 <- raster::extract(lc_stack3, points21.proj)
```


2. Turn matrices into tables/dataframes and join with original point ids

```{r}
lc19.join <- as.data.frame(cbind(points19.proj, lc.19))
lc21.join <- as.data.frame(cbind(points21.proj, lc.21))

```

3. Merge (add) land cover types into specified groups
```{r}
# 2019
colnames(lc19.join)

lc19.join2 <- lc19.join %>%
  mutate(forest = egforest + decforest + mixforest + woodland,
         bare = barren + sparseveg,
         wetland = bog + fen + littoral)

# take out extra columns (ones that were added together) and reorder
colnames(lc19.join2)
lc19.join3 <- lc19.join2[,c(1, 6:10, 16, 18:20)]


# 2021
colnames(lc21.join)

lc21.join2 <- lc21.join %>%
  mutate(forest = egforest + decforest + mixforest + woodland,
         bare = barren + sparseveg,
         wetland = bog + fen + littoral)

colnames(lc21.join2)
lc21.join3 <- lc21.join2[,c(1, 6:10, 16, 18:20)]
```





